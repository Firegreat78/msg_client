// Copyright 2025 Medvedev Dan (https://github.com/Firegreat78)

/*
Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#include "socketmanager.h"
#include "logger.h"
#include <QJsonDocument>

QString const IP_ADDRESS = "127.0.0.1";
quint16 const PORT = 6000;
QString const ADDRESS = IP_ADDRESS + "::" + QString::number(PORT);

SocketManager::SocketManager(QObject *parent)
    : QObject{parent}
{
    try
    {
        socket = std::make_unique<QTcpSocket>();
        socket->setReadBufferSize(SOCKET_BUFFER);
    }

    catch (std::exception const& e)
    {
        std::string msg = std::string("QTcpSocket failed to initialize with exception: ") + e.what();
        Logger::getInstance().log(msg);
        std::exit(EXIT_FAILURE);
    }
    connect(socket.get(), &QTcpSocket::connected, this, &SocketManager::onSocketConnected);
    connect(socket.get(), &QTcpSocket::disconnected, this, &SocketManager::onSocketDisconnected);
    connect(socket.get(), &QTcpSocket::errorOccurred, this, &SocketManager::onSocketError);
    connect(socket.get(), &QTcpSocket::readyRead, this, &SocketManager::onSocketReadyRead);
}

// TODO: change type to QByteArray
size_t getFirstCompletedIndex(std::string const& chunk)
{
    int depth = 0;
    bool insideString = false;

    for (size_t i = 0; i < chunk.size(); i++)
    {
        char const c = chunk[i];

        if (c == '"')
        {
            size_t bs = 0; // backslashes
            size_t k = i;
            while (k > 0 && chunk[k-1] == '\\')
            {
                ++bs;
                --k;
            }
            if ((bs % 2) == 0) insideString = !insideString;
        }

        if (insideString) continue;

        if (c == '{') ++depth;
        if (c == '}') --depth;

        if (depth == 0 && c == '}') return i + 1;
    }
    return 0;
}
void SocketManager::onSocketConnected()
{
    isConnected = (socket->state() == QAbstractSocket::ConnectedState);
}

void SocketManager::onSocketDisconnected()
{
    isConnected = false;
}

void SocketManager::onSocketError(QAbstractSocket::SocketError e)
{
    isConnected = false;
}

void SocketManager::onSocketReadyRead()
{
    Logger& logger = Logger::getInstance();
    accumulated += socket->readAll();
    while (true)
    {
        size_t const index = getFirstCompletedIndex(accumulated.toStdString());
        if (index == 0) return;
        QByteArray const json_first = accumulated.left(index);
        accumulated.remove(0, index);
        QJsonParseError error;
        QJsonDocument doc = QJsonDocument::fromJson(json_first, &error);
        if (error.error != QJsonParseError::NoError)
        {
            logger.log("JSON parse error happened inside SocketManager::onSocketReadyRead() function");
            continue;
        }
        QJsonObject js = doc.object();
        this->enqueue(js);
    }
}

void SocketManager::enqueue(QJsonObject const& js)
{
    QString const type = js["type"].toString();
    if (type == "userLoginResponse" ||
        type == "userRegisterResponse")
    {
        mainWinQ.enqueue(js);
        emit arrivedJSMainWin();
    }
    else if (type == "changeUsernameResponse" ||
             type == "changePasswordResponse")
    {

        infoUserWinQ.enqueue(js);
        emit arrivedJSInfoUserWin();
    }
    else
    {
        baseWinQ.enqueue(js);
        emit arrivedJSBaseWin();
    }
}

void SocketManager::tryConnect()
{
    if (socket->state() != QAbstractSocket::UnconnectedState)
    {
        socket->abort();
    }
    socket->connectToHost(QHostAddress(IP_ADDRESS), PORT);
}

SocketManager& SocketManager::getInstance()
{
    static SocketManager obj;
    return obj;
}

QTcpSocket const* SocketManager::getSocket()
{
    return socket.get();
}


bool SocketManager::sendJSON(QJsonObject const& js)
{
    Logger& logger = Logger::getInstance();
    try
    {
        QJsonDocument doc(js);
        QByteArray js_bytes = doc.toJson(QJsonDocument::Compact);
        qsizetype size = js_bytes.size();
        qsizetype total_written = 0;
        while (total_written < size)
        {
            qint64 const written = socket->write(js_bytes.constData() + total_written, size - total_written);
            if (written == -1)
            {
                logger.log("socket->write() returned -1");
                return false;
            }
            total_written += written;
        }
        return true;
    }

    catch (std::exception const& e)
    {
        logger.log(std::string("Exception occured when executing SocketManager::sendJSON: ") + e.what());
        return false;
    }
}

bool SocketManager::isConnectedToServer()
{
    return SocketManager::getInstance().isConnected;
}

std::optional<QJsonObject> SocketManager::popJSON(int64_t const q_index)
{
    if (q_index == 1) return popJSMainWin();
    if (q_index == 2) return popJSBaseWin();
    if (q_index == 3) return popJSInfoUserWin();
    return {};
}

std::optional<QJsonObject> SocketManager::popJSMainWin()
{
    if (mainWinQ.empty()) return {};
    return mainWinQ.dequeue();
}

std::optional<QJsonObject> SocketManager::popJSBaseWin()
{
    if (baseWinQ.empty()) return {};
    return baseWinQ.dequeue();
}

std::optional<QJsonObject> SocketManager::popJSInfoUserWin()
{
    if (infoUserWinQ.empty()) return {};
    return infoUserWinQ.dequeue();
}
