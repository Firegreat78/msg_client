// Copyright 2025 Medvedev Dan (https://github.com/Firegreat78)

/*
Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#include "basewindow.h"
#include "ui_basewindow.h"

#include "windowmanager.h"
#include "socketmanager.h"
#include "logger.h"
#include "messageinfo.h"
#include "JsonTypes.h"


#include <QTimer>
#include <QJsonObject>
#include <QJsonArray>
#include <QJsonDocument>
#include <QMessageBox>

BaseWindow::BaseWindow(QWidget *parent)
    : QMainWindow(parent), ui(new Ui::BaseWindow)
{
    ui->setupUi(this);
    SocketManager& sm = SocketManager::getInstance();
    QTcpSocket const* const socket = sm.getSocket();

    heartbeatTimer = new QTimer(this);
    updateVisibleDataTimer = new QTimer(this);

    connect(socket, &QTcpSocket::connected, this, &BaseWindow::onSocketConnected);
    connect(socket, &QTcpSocket::disconnected, this, &BaseWindow::onSocketDisconnected);
    connect(socket, &QTcpSocket::errorOccurred, this, &BaseWindow::onSocketError);

    connect(ui->accInfoAction, &QAction::triggered, this, &BaseWindow::showAccountInfoWindow);
    connect(ui->reTryToConnectAction, &QAction::triggered, this, &BaseWindow::retryToConnect);
    connect(ui->exitAccountAction, &QAction::triggered, this, &BaseWindow::exitAccountActionClicked);
    connect(ui->sendMessageButton, &QPushButton::clicked, this, &BaseWindow::sendMessageButtonClicked);
    connect(ui->updateChatsButton, &QPushButton::clicked, this, &BaseWindow::updateChatsButtonClicked);
    connect(ui->chatsListWidget, &QListWidget::itemDoubleClicked, this, &BaseWindow::chatListDoubleClicked);

    connect(updateVisibleDataTimer, &QTimer::timeout, this, &BaseWindow::updateVisibleData);


    connect(&sm, &SocketManager::arrivedJSBaseWin, this, &BaseWindow::onJsonArrived);

    chat = new ChatWidget(this);
    chat->setGeometry(QRect(291, 100, 1546, 695));
    ui->setFilterButton->setEnabled(false);

    connect(ui->setFilterButton, &QPushButton::clicked, this, &BaseWindow::setFilterButtonClicked);
}

BaseWindow::~BaseWindow()
{
    delete ui;
}

// The code that would execute after we show this window via singleton WindowManager
void BaseWindow::customShow()
{
    SocketManager& sm = SocketManager::getInstance();
    WindowManager& wm = WindowManager::getInstance();
    bool const connected = SocketManager::isConnectedToServer();
    ui->sendMessageButton->setEnabled(connected);
    ui->reTryToConnectAction->setEnabled(!connected);

    ui->answerTextLabel->setVisible(false);
    ui->answerInfoLabel->setVisible(false);

    chat->clear();
    ui->chatsListWidget->clear();
    if (!connected)
    {
        ui->connectionStatusAction->setText("Статус подключения: Соединение с сервером отсутствует");
        return;
    }

    updateVisibleDataTimer->start(UPDATE_TIMER_DELAY);
    ui->connectionStatusAction->setText("Статус подключения: Соединение с сервером присутствует");

    QJsonObject js;
    js["type"] = UPDATE_CHAT_LIST;
    js["id"] = wm.user_id;
    sm.sendJSON(js);
}

// The code that would execute after we hide this window via singleton WindowManager
void BaseWindow::customHide()
{
    isActive = false;

    ui->setFilterButton->setEnabled(false);
    WindowManager::getInstance().chat_id = 0;
    WindowManager::getInstance().user_id_2 = 0;
    chat->resetPendingAnswerMsg();
    chat->resetPendingEditMsg();
}

// The trick needed for customShow to work as intended
void BaseWindow::showEvent(QShowEvent* e)
{
    QMainWindow::showEvent(e);

    if (isActive) return;
    isActive = true;

    this->customShow();
}

void BaseWindow::closeEvent(QCloseEvent* e)
{
    QMainWindow::closeEvent(e);
}

void BaseWindow::hideEvent(QHideEvent* e)
{
    QMainWindow::hideEvent(e);
}

// escape characters for filtering in DB
QString BaseWindow::escapedFilterText()
{
    QString const input = ui->filterLineEdit->text();
    QString escaped;
    for (qsizetype i = 0; i < input.length(); i++)
    {
        QChar const ch = input[i];
        if (ch == '\\' || ch == '%' || ch == '_') {
            escaped += '\\';
        }
        escaped += ch;
    }
    return escaped;
}

void BaseWindow::onSocketConnected()
{
    ui->connectionStatusAction->setText("Статус подключения: Соединение с сервером присутствует");
    ui->reTryToConnectAction->setEnabled(false);
    ui->sendMessageButton->setEnabled(true);
    ui->setFilterButton->setEnabled(true);
}

void BaseWindow::onSocketDisconnected()
{
    ui->connectionStatusAction->setText("Статус подключения: Соединение с сервером отсутствует");
    ui->reTryToConnectAction->setEnabled(true);
    ui->sendMessageButton->setEnabled(false);
    ui->setFilterButton->setEnabled(false);
    updateVisibleDataTimer->start(UPDATE_TIMER_DELAY);
}

void BaseWindow::onSocketError(QAbstractSocket::SocketError error)
{
    ui->connectionStatusAction->setText("Статус подключения: Соединение с сервером отсутствует");
    ui->reTryToConnectAction->setEnabled(true);
    ui->sendMessageButton->setEnabled(false);
    ui->setFilterButton->setEnabled(false);
    updateVisibleDataTimer->start(UPDATE_TIMER_DELAY);
}

void BaseWindow::retryToConnect()
{
    SocketManager::getInstance().tryConnect();
}

void BaseWindow::onJsonArrived()
{
    WindowManager& wm = WindowManager::getInstance();

    Logger& logger = Logger::getInstance();
    SocketManager& sm = SocketManager::getInstance();
    std::optional<QJsonObject> js = sm.popJSON(BASE_WINDOW);
    if (js.has_value())
    {
        logger.logJSON("Handling JSON: ", js.value());
        handleJSON(js.value());
    }
}

void BaseWindow::showAccountInfoWindow()
{
    WindowManager& wm = WindowManager::getInstance();
    QTcpSocket const* const socket = SocketManager::getInstance().getSocket();
    disconnect(socket, &QTcpSocket::connected, this, &BaseWindow::onSocketConnected);
    disconnect(socket, &QTcpSocket::disconnected, this, &BaseWindow::onSocketDisconnected);
    disconnect(socket, &QTcpSocket::errorOccurred, this, &BaseWindow::onSocketError);
    wm.showWindow("InfoUserWindow");
}

void BaseWindow::exitAccountActionClicked()
{
    WindowManager& wm = WindowManager::getInstance();
    wm.hideAllWindows();
    wm.showWindow("MainWindow");
    int64_t const userID = wm.user_id;
    this->customHide();

    if (!SocketManager::isConnectedToServer()) return;

    QJsonObject js;
    js["type"] = EXIT_ACCOUNT;
    js["id"] = userID;
    SocketManager::getInstance().sendJSON(js);
}

void BaseWindow::sendMessageButtonClicked()
{
    WindowManager& wm = WindowManager::getInstance();
    SocketManager& sm = SocketManager::getInstance();
    QString msg = ui->messageTextEdit->toPlainText().trimmed();
    if (msg.length() == 0)
    {
        return;
    }
    if (chat->getMsgPendingEdit() != 0)
    {
        QJsonObject js;
        js["type"] = UPDATE_MESSAGE;
        js["msg_id"] = chat->getMsgPendingEdit();
        js["new_content"] = msg;
        sm.sendJSON(js);
        chat->resetPendingEditMsg();
        ui->sendMessageButton->setText("Отправить");
        ui->messageTextEdit->setText("");
        return;
    }
    QJsonObject js;
    js["type"] = SEND_MESSAGE;
    js["chat_id"] = wm.chat_id; // may be 0
    js["content"] = msg;
    js["sender_id"] = wm.user_id;
    if (isPrivateChat)
    {
        js["receiver_id"] = wm.user_id_2;
    }
    else
    {

    }
    if (chat->getMsgPendingAnswer() != 0)
    {
        js["answer_to"] = chat->getMsgPendingAnswer();
        chat->resetPendingAnswerMsg();
        ui->sendMessageButton->setText("Отправить");
    }
    sm.sendJSON(js);
    ui->messageTextEdit->setText("");
}

void BaseWindow::updateChatsButtonClicked()
{
    WindowManager& wm = WindowManager::getInstance();
    SocketManager& sm = SocketManager::getInstance();

    if (!SocketManager::isConnectedToServer()) return;

    // Update list on the left
    QJsonObject js;
    js["type"] = UPDATE_CHAT_LIST;
    js["id"] = wm.user_id;
    sm.sendJSON(js);
}

void BaseWindow::chatListDoubleClicked(QListWidgetItem* item)
{
    bool const is_chat_deleted = item->data(Qt::UserRole + 1).toBool();
    if (!SocketManager::isConnectedToServer() || is_chat_deleted) return;

    isLoadingMsgs = true;
    ui->setFilterButton->setEnabled(true);
    resetFilter();
    chat->resetPendingAnswerMsg();
    chat->resetPendingEditMsg();
    ui->sendMessageButton->setText("Отправить");
    WindowManager& wm = WindowManager::getInstance();
    QJsonObject js;
    isPrivateChat = true;
    js["is_private_chat"] = isPrivateChat;
    js["type"] = LOAD_CHAT;
    js["sender_id"] = wm.user_id;
    js["msg_amount"] = MAX_CHAT_MESSAGES;
    if (isPrivateChat)
    {
        wm.user_id_2 = item->data(Qt::UserRole).toLongLong();
        js["recv_id"] = wm.user_id_2;
    }
    SocketManager::getInstance().sendJSON(js);
}

// Filter button
void BaseWindow::setFilterButtonClicked()
{
    WindowManager& wm = WindowManager::getInstance();
    this->filterContent = escapedFilterText();
    this->filterDtBegin = ui->dateTimeFirst->dateTime();
    this->filterDtEnd = ui->dateTimeLast->dateTime();
    this->isFilterDtEnabled = ui->checkBoxEnableFilterBySentAt->isChecked();
    this->onlyUnreadFilter = ui->checkBoxEnableFilterByUnread->isChecked();
    if (!SocketManager::isConnectedToServer() || wm.user_id_2 == 0) return;
    isLoadingMsgs = true;
    ui->sendMessageButton->setText("Отправить");
    QJsonObject js;
    js["type"] = LOAD_CHAT_FILTER;
    js["is_private_chat"] = isPrivateChat;
    js["sender_id"] = wm.user_id;
    js["msg_amount"] = MAX_CHAT_MESSAGES;
    if (isPrivateChat)
    {
        js["recv_id"] = wm.user_id_2;
    }
    else
    {
        // TODO: js["chat_id"] =
    }
    js["filter_content"] = filterContent;
    js["filter_dt_enabled"] = isFilterDtEnabled;
    if (isFilterDtEnabled)
    {
        js["filter_dt_begin"] = filterDtBegin.toUTC().toString("yyyy-MM-dd HH:mm:ss") + "Z";
        js["filter_dt_end"] = filterDtEnd.toUTC().toString("yyyy-MM-dd HH:mm:ss") + "Z";
    }
    js["filter_unread_enabled"] = onlyUnreadFilter;
    js["user_id"] = wm.user_id;

    SocketManager::getInstance().sendJSON(js);
}

// autoupdate data on the screen.
// Works if someone changes ther message/their username
// also, this is for requesting older msgs in case user scrolls up just enough
void BaseWindow::updateVisibleData()
{
    if (!isActive || !SocketManager::isConnectedToServer()) return;

    WindowManager& wm = WindowManager::getInstance();
    SocketManager& sm = SocketManager::getInstance();

    QJsonObject jsOnlineStatus;
    jsOnlineStatus["type"] = CHANGE_ONLINE_STATUS;
    jsOnlineStatus["id"] = wm.user_id;
    jsOnlineStatus["is_online"] = this->isActiveWindow() ||
                                  wm.getWindow("InfoUserWindow")->isActiveWindow();
    sm.sendJSON(jsOnlineStatus);

    // If chat info changes and we want to update it on the lhs of the screen
    // without requesting new chats
    QJsonArray users_ids;
    for (int i = 0; i < ui->chatsListWidget->count(); i++)
    {
        QListWidgetItem* item = ui->chatsListWidget->item(i);
        qint64 const user_id = item->data(Qt::UserRole).toLongLong();
        users_ids.append(user_id);
    }
    if (ui->chatsListWidget->count() > 0)
    {
        QJsonObject js;
        js["type"] = UPDATE_USERS_LIST;
        js["users_ids"] = users_ids;
        js["logon_user_id"] = wm.user_id;
        sm.sendJSON(js);
    }

    // for unititialized private chat:
    // don't request new msgs
    // don't update frontend msgs
    if (wm.chat_id == 0) return;

    {
        QJsonObject js;
        js["type"] = UPDATE_FRONTEND_MESSAGES;
        js["chat_id"] = wm.chat_id;
        js["logon_user_id"] = wm.user_id;
        QJsonArray frontend_messages;
        std::vector<int64_t> message_ids = chat->getVisibleMessagesID();
        for (auto const& id : message_ids)
            frontend_messages.append(id);
        js["messages"] = frontend_messages;

        if (chat->getMsgPendingAnswer() != 0)
            js["pending_msg_id"] = chat->getMsgPendingAnswer();
        else if (chat->getMsgPendingEdit() != 0)
            js["pending_msg_id"] = chat->getMsgPendingEdit();


        sm.sendJSON(js);
    }
    if (chat->messageAmount() > 0)
    {
        QJsonObject js;
        js["type"] = COUNT_UNREAD;
        js["chat_id"] = wm.chat_id;
        js["logon_user_id"] = wm.user_id;
        js["chat_top_msg"] = chat->firstMessageID();
        js["chat_bottom_msg"] = chat->lastMessageID();

        js["filter_content"] = filterContent;
        js["filter_dt_enabled"] = isFilterDtEnabled;
        if (isFilterDtEnabled)
        {
            js["filter_dt_begin"] = filterDtBegin.toUTC().toString("yyyy-MM-dd HH:mm:ss") + "Z";
            js["filter_dt_end"] = filterDtEnd.toUTC().toString("yyyy-MM-dd HH:mm:ss") + "Z";
        }
        sm.sendJSON(js);
    }
    if (chat->messageAmount() < MAX_CHAT_MESSAGES)
    {
        QJsonObject js;
        js["type"] = REQUEST_ARRIVED_MESSAGES;
        js["chat_id"] = wm.chat_id;
        js["filter_content"] = filterContent;
        js["filter_dt_enabled"] = isFilterDtEnabled;
        js["last_msg_id"] = chat->lastMessageID();
        js["msg_amount"] = MAX_CHAT_MESSAGES - chat->messageAmount();
        if (isFilterDtEnabled)
        {
            js["filter_dt_begin"] = filterDtBegin.toUTC().toString("yyyy-MM-dd HH:mm:ss") + "Z";
            js["filter_dt_end"] = filterDtEnd.toUTC().toString("yyyy-MM-dd HH:mm:ss") + "Z";
        }
        js["filter_unread_enabled"] = onlyUnreadFilter;
        js["user_id"] = wm.user_id;
        sm.sendJSON(js);
    }
    else if (chat->isScrolledUp())
    {
        int64_t upperMsg = chat->firstMessageID();
        QJsonObject js;
        js["type"] = REQUEST_UPPER_MESSAGES;
        js["chat_id"] = wm.chat_id;
        js["upper_msg_id"] = upperMsg;
        js["max_msg_amount"] = MAX_CHAT_MESSAGES/2;
        js["filter_content"] = filterContent;
        js["filter_dt_enabled"] = isFilterDtEnabled;
        if (isFilterDtEnabled)
        {
            js["filter_dt_begin"] = filterDtBegin.toUTC().toString("yyyy-MM-dd HH:mm:ss") + "Z";
            js["filter_dt_end"] = filterDtEnd.toUTC().toString("yyyy-MM-dd HH:mm:ss") + "Z";
        }
        js["filter_unread_enabled"] = onlyUnreadFilter;
        js["user_id"] = wm.user_id;
        sm.sendJSON(js);
    }
    else if (chat->isScrolledDown())
    {
        int64_t lowerMsg = chat->lastMessageID();
        QJsonObject js;
        js["type"] = REQUEST_LOWER_MESSAGES;
        js["chat_id"] = wm.chat_id;
        js["lower_msg_id"] = lowerMsg;
        js["max_msg_amount"] = MAX_CHAT_MESSAGES/2;
        js["filter_content"] = filterContent;
        js["filter_dt_enabled"] = isFilterDtEnabled;
        if (isFilterDtEnabled)
        {
            js["filter_dt_begin"] = filterDtBegin.toUTC().toString("yyyy-MM-dd HH:mm:ss") + "Z";
            js["filter_dt_end"] = filterDtEnd.toUTC().toString("yyyy-MM-dd HH:mm:ss") + "Z";
        }
        js["filter_unread_enabled"] = onlyUnreadFilter;
        js["user_id"] = wm.user_id;
        sm.sendJSON(js);
    }
}

void BaseWindow::onSelectedMsgAnswer(int64_t const, QString const username, QString const text)
{
    ui->answerInfoLabel->setVisible(true);
    ui->answerInfoLabel->setText("Ответ на сообщение "+username+":");
    ui->answerTextLabel->setVisible(true);
    ui->answerTextLabel->setText(text);
    ui->sendMessageButton->setText("Ответить");

}

void BaseWindow::onCancelAnswering()
{
    ui->answerInfoLabel->setVisible(false);
    ui->answerTextLabel->setVisible(false);
    ui->sendMessageButton->setText("Отправить");
}

void BaseWindow::onSelectedMsgEdit(int64_t const, QString const text)
{
    ui->answerInfoLabel->setVisible(true);
    ui->answerInfoLabel->setText("Редактирование сообщения:");
    ui->answerTextLabel->setVisible(true);
    ui->answerTextLabel->setText(text);
    ui->sendMessageButton->setText("Редактировать");
}

void BaseWindow::onCancelEdit()
{
    ui->answerInfoLabel->setVisible(false);
    ui->answerTextLabel->setVisible(false);
    ui->sendMessageButton->setText("Отправить");
}

// drop-down menu will block the 'delete' button
// if no server connection
void BaseWindow::onDeleteMsg(int64_t id)
{
    QJsonObject js;
    js["type"] = DELETE_MESSAGE;
    js["id"] = id;
    SocketManager::getInstance().sendJSON(js);
}

void BaseWindow::gotoMsg(int64_t id)
{
    if (chat->isMsgPresent(id))
    {
        chat->gotoMessage(id, 0);
        chat->highlight(id, 3000);
        return;
    }
    if (!SocketManager::isConnectedToServer()) return;
    pendingGotoMsg = true;
    WindowManager& wm = WindowManager::getInstance();
    QJsonObject js;
    js["type"] = GOTO_MSG;
    js["id"] = id;
    js["max_chat_msgs"] = MAX_CHAT_MESSAGES;
    js["chat_id"] = wm.chat_id;
    SocketManager::getInstance().sendJSON(js);
}

// HANDLERS
void BaseWindow::handleJSON(QJsonObject const& js)
{
    Logger& logger = Logger::getInstance();
    int const type = js["type"].toInt();

    if (type == ERROR_TYPE)
    {
        std::string const msg = std::string("Server error occurred: ") +
            js["info"].toString().toStdString();
        Logger::getInstance().log(msg);
        return;
    }
    QJsonObject response = js["response"].toObject();
    if (type == UPDATE_CHAT_LIST) chatListResponseHandler(response);
    else if (type == UPDATE_USERS_LIST) updateUsersListResponseHandler(response);
    else if (type == LOAD_CHAT) loadChatResponseHandler(response);
    else if (type == LOAD_CHAT_FILTER) loadChatFilterHandler(response);
    else if (type == SEND_MESSAGE) sendMessageResponseHandler(response);
    else if (type == REQUEST_ARRIVED_MESSAGES) getNewChatMsgResponse(response);
    else if (type == UPDATE_FRONTEND_MESSAGES) updateFrontendMsgsHandler(response);
    else if (type == REQUEST_LOWER_MESSAGES) requestLowerMsgsResponse(response);
    else if (type == REQUEST_UPPER_MESSAGES) requestUpperMsgsResponse(response);
    else if (type == GOTO_MSG) gotoMsgHandler(response);
    else if (type == COUNT_UNREAD) countUnreadMsgsHandler(response);
}

// Initial loading
// TODO: group chats support
void BaseWindow::chatListResponseHandler(QJsonObject const& response)
{
    bool success = (response["success"] == 1);
    if (!success) return;

    QJsonArray const usernames = response["usernames"].toArray();
    QJsonArray const ids = response["user_ids"].toArray(); // recv user ids
    QJsonArray const last_msg_contents = response["last_msg_contents"].toArray();
    QJsonArray const last_msg_ts = response["last_msg_ts"].toArray();
    QJsonArray const last_msg_username = response["last_msg_username"].toArray();
    QJsonArray const online_statuses = response["online_statuses"].toArray();
    QJsonArray const last_seen_onlines = response["last_seen_online"].toArray();
    QJsonArray const unread_msgs_cnt = response["unread_msgs_cnt"].toArray();
    ui->chatsListWidget->clear();
    for (int i = 0; i < ids.size(); ++i)
    {
        QString const name = usernames[i].toString(); // @username or group chat name
        qint64 const user_id = ids[i].toInteger();
        bool const is_cont_null = last_msg_contents[i].isNull();
        QString const msg_cont =
            is_cont_null ? "" : last_msg_contents[i].toString();
        QString const msg_ts =
            is_cont_null ? "" : last_msg_ts[i].toString();
        QString msg_username =
            is_cont_null ? "" : last_msg_username[i].toString();

        bool const is_online = online_statuses[i].toBool();
        QString last_seen_online = last_seen_onlines[i].toString();
        int64_t const unread_cnt = unread_msgs_cnt[i].toInteger();
        QString itemText = QString("%1"
                                   "%2"
                                   "%3"
                                   "%4"
                                   "%5"
                                   "%6"
                                   "%7")
                               .arg(
                                   name,
                                   is_online ? "\nВ сети" : QString("\nБыл в сети %1").arg(WindowManager::convertToLocalTimeString(last_seen_online)),
                                   is_cont_null ? "" : "\n\nПоследнее сообщение",
                                   is_cont_null ? "" : "\n" + msg_username,
                                   is_cont_null ? "" : "\n" + WindowManager::convertToLocalTimeString(msg_ts),
                                   is_cont_null ? "" : "\n" + (msg_cont.length() > 15 ? msg_cont.first(15)+"..." : msg_cont),
                                   unread_cnt == 0 ? "" : "\n\nНепрочитанных сообщений: " + QString::number(unread_cnt)
                                   );
        QListWidgetItem* item = new QListWidgetItem(itemText);

        item->setData(Qt::UserRole, user_id); // user ID/group chat ID
        item->setData(Qt::UserRole+1, false); // is_profile_deleted

        ui->chatsListWidget->addItem(item);
    }
}

// Initial chat loading after double-click
void BaseWindow::loadChatResponseHandler(QJsonObject const& response)
{
    bool success = (response["success"] == 1);
    if (!success)
    {
        return;
    }
    WindowManager& wm = WindowManager::getInstance();
    QJsonArray messages = response["messages"].toArray();

    // if chat_id == 0, then there are no messages in the private chat yet
    auto const chat_id = response["chat_id"].toInteger();
    wm.chat_id = chat_id; // 0 if not initialized yet (lazy initialization)
    int64_t const oldest_unread_id = response["oldest_unread_id"].toInteger();
    chat->clear();
    chat->resetPendingAnswerMsg();
    chat->resetPendingEditMsg();
    for (int i = 0; i < messages.size(); ++i)
    {
        QJsonObject const message = messages[i].toObject();
        MessageInfo info = MessageInfo::fromJS(message);
        chat->addMessage(info, true);
    }

    QTimer::singleShot(20, this, [this, oldest_unread_id](){
        if (oldest_unread_id == 0)
            chat->scroll(0, 1.0);
        else
            chat->gotoMessage(oldest_unread_id, 0);
        isLoadingMsgs = false;
    });

}

void BaseWindow::loadChatFilterHandler(QJsonObject const& response)
{
    bool success = (response["success"] == 1);
    if (!success) return;

    WindowManager& wm = WindowManager::getInstance();
    QJsonArray messages = response["messages"].toArray();
    chat->clear();
    for (int i = 0; i < messages.size(); ++i)
    {
        QJsonObject const message = messages[i].toObject();
        MessageInfo info = MessageInfo::fromJS(message);
        chat->addMessage(info, true);
    }
    QTimer::singleShot(20, this, [this](){
        chat->scroll(0, 1.0);
        isLoadingMsgs = false;
    });
}

void BaseWindow::sendMessageResponseHandler(QJsonObject const& response)
{
    WindowManager& wm = WindowManager::getInstance();
    bool success = (response["success"] == 1);
    if (!success || !SocketManager::isConnectedToServer()) return;
    if (response.contains("chat_id"))
        wm.chat_id = response["chat_id"].toInteger();
    ui->messageTextEdit->setText("");
}

// new messages arriving in case when there are
// less than MAX_CHAT_MESSAGES messages in the chat's scope
void BaseWindow::getNewChatMsgResponse(QJsonObject const& response)
{
    bool success = (response["success"] == 1);
    if (!success || pendingGotoMsg || isLoadingMsgs) return;

    WindowManager& wm = WindowManager::getInstance();
    QJsonArray messages = response["messages"].toArray();

    for (int i = 0; i < messages.size(); ++i)
    {
        QJsonObject const message = messages[i].toObject();
        MessageInfo const info = MessageInfo::fromJS(message);
        chat->addMessage(info, true);
    }
}

void BaseWindow::requestLowerMsgsResponse(QJsonObject const& response)
{
    bool success = (response["success"] == 1);

    // We need to return from func while we about to go to some message
    // because
    if (!success || pendingGotoMsg || isLoadingMsgs) return;

    QJsonArray messages = response["messages"].toArray();

    for (int i = 0; i < messages.size(); ++i)
    {
        chat->pop_front();
        QJsonObject const message = messages[i].toObject();
        MessageInfo const info = MessageInfo::fromJS(message);
        chat->addMessage(info, true);
    }
    if (!messages.empty()) chat->scroll(50, 0.7);
}

void BaseWindow::requestUpperMsgsResponse(QJsonObject const& response)
{
    bool success = (response["success"] == 1);
    if (!success || pendingGotoMsg || isLoadingMsgs) return;

    QJsonArray messages = response["messages"].toArray();

    for (int i = messages.size(); i > 0; --i)
    {
        chat->pop_back();
        QJsonObject const message = messages[i-1].toObject();
        MessageInfo const info = MessageInfo::fromJS(message);
        chat->addMessage(info, false);
    }
    if (!messages.empty()) chat->scroll(50, 0.3);
}

void BaseWindow::updateFrontendMsgsHandler(QJsonObject const& response)
{
    bool success = (response["success"] == 1);
    if (!success || pendingGotoMsg || isLoadingMsgs) return;

    WindowManager& wm = WindowManager::getInstance();
    QJsonArray messages = response["messages"].toArray();

    for (int i = 0; i < messages.size(); ++i)
    {
        QJsonObject const message = messages[i].toObject();
        MessageInfo const info = MessageInfo::fromJS(message);
        bool const isDeleted = message["is_deleted"].toBool();
        if (isDeleted)
        {
            if (chat->getMsgPendingAnswer() == info.id)
                chat->resetPendingAnswerMsg();
            if (chat->getMsgPendingEdit() == info.id)
                chat->resetPendingEditMsg();

            chat->removeMessage(info.id);
            continue;
        }
        chat->updateInfo(info.id, info);
    }

    // this is for dynamic updating labels if answer/edit selected
    if (response.contains("pending_msg"))
    {
        QJsonObject msg = response["pending_msg"].toArray()[0].toObject();

        QString text = msg["content"].toString();
        int const MAX_CHARS = 30;
        if (text.length() > MAX_CHARS) text = text.first(MAX_CHARS) + "...";


        if (chat->getMsgPendingAnswer() != 0)
        {
            QString const username = "@" + msg["sender_username"].toString();
            ui->answerInfoLabel->setText("Ответ на сообщение "+username+":");
        }
        else
            ui->answerInfoLabel->setText("Редактирование сообщения:");

        ui->answerTextLabel->setText(text);
        ui->answerInfoLabel->setVisible(true);
        ui->answerTextLabel->setVisible(true);
    }
    else
    {
        ui->answerInfoLabel->setVisible(false);
        ui->answerTextLabel->setVisible(false);
    }
}

void BaseWindow::updateUsersListResponseHandler(QJsonObject const& response)
{
    bool success = (response["success"] == 1);
    if (!success) return;

    QJsonArray const usernames = response["usernames"].toArray();
    QJsonArray const deleted_statuses = response["deleted_statuses"].toArray();
    QJsonArray const last_msg_contents = response["last_msg_contents"].toArray();
    QJsonArray const last_msg_ts = response["last_msg_ts"].toArray();
    QJsonArray const last_msg_username = response["last_msg_username"].toArray();
    QJsonArray const online_statuses = response["online_statuses"].toArray();
    QJsonArray const last_seen_onlines = response["last_seen_online"].toArray();
    QJsonArray const unread_msgs_cnt = response["unread_msgs_cnt"].toArray();

    for (int i = 0; i < ui->chatsListWidget->count(); i++)
    {
        QListWidgetItem* item = ui->chatsListWidget->item(i);

        if (item == nullptr) continue;
        if (item->data(Qt::UserRole + 1).toBool()) continue;

        QString const name = usernames[i].toString();
        bool const is_user_deleted = deleted_statuses[i].toBool(false);

        if (is_user_deleted)
        {
            item->setData(Qt::UserRole + 1, true);
            QString itemText = QString(
                "%1"
                "\nПользователь удалил свою учётную запись"
                ).arg(name);
            item->setText(itemText);
            continue;
        }

        bool const is_cont_null = last_msg_contents[i].isNull();
        QString const msg_cont =
            is_cont_null ? "" : last_msg_contents[i].toString();
        QString const msg_ts =
            is_cont_null ? "" : last_msg_ts[i].toString();
        QString msg_username =
            is_cont_null ? "" : last_msg_username[i].toString();

        bool const is_online = online_statuses[i].toBool();
        QString last_seen_online = last_seen_onlines[i].toString();
        int64_t const unread_cnt = unread_msgs_cnt[i].toInteger(0);
        QString itemText = QString("%1"
                                   "%2"
                                   "%3"
                                   "%4"
                                   "%5"
                                   "%6"
                                   "%7")
                               .arg(
                                name,
                                is_online ? "\nВ сети" :
                                    QString("\nБыл в сети %1").arg(WindowManager::convertToLocalTimeString(last_seen_online)),
                                is_cont_null ? "" : "\n\nПоследнее сообщение",
                                is_cont_null ? "" : "\n" + msg_username,
                                is_cont_null ? "" : "\n" + WindowManager::convertToLocalTimeString(msg_ts),
                                is_cont_null ? "" : "\n" + (msg_cont.length() >= 15 ? msg_cont.first(15)+"..." : msg_cont),
                                unread_cnt == 0 ? "" : "\n\nНепрочитанных сообщений: " + QString::number(unread_cnt)
        );

        item->setText(itemText);
    }
}


// if the message is out of scope
void BaseWindow::gotoMsgHandler(QJsonObject const& response)
{
    bool success = (response["success"] == 1);
    if (!success) return;

    chat->clear();
    this->resetFilter();
    QJsonArray messages = response["messages"].toArray();
    int64_t const msg_id = response["msg_id"].toInteger();
    for (int i = 0; i < messages.size(); ++i)
    {
        QJsonObject const message = messages[i].toObject();
        MessageInfo const info = MessageInfo::fromJS(message);
        chat->addMessage(info, true);
    }

    QTimer::singleShot(20, this, [msg_id, this](){
        chat->gotoMessage(msg_id, 0);
        chat->highlight(msg_id, 3000);
        pendingGotoMsg = false;
    });
}

void BaseWindow::countUnreadMsgsHandler(QJsonObject const& response)
{
    ui->actionUpperUnreads->setText(
        "Непрочитанных сообщений выше текущей области: "
        + QString::number(response["above"].toInteger())
        );
    ui->actionMiddleUnreads->setText(
        "Непрочитанных сообщений в текущей области: "
        + QString::number(response["inside"].toInteger())
        );
    ui->actionLowerUnreads->setText(
        "Непрочитанных сообщений ниже текущей области: "
        + QString::number(response["below"].toInteger())
        );
}

void BaseWindow::resetFilter()
{
    filterContent = "";
    isFilterDtEnabled = false;
    onlyUnreadFilter = false;
}
