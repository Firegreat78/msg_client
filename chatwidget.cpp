// Copyright 2025 Medvedev Dan (https://github.com/Firegreat78)

/*
Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#include "chatwidget.h"
#include "windowmanager.h"
#include "basewindow.h"
#include "socketmanager.h"

#include <QDateTime>
#include <QLabel>
#include <QPointer>
#include <QScrollBar>

ChatWidget::ChatWidget(QWidget *parent)
    : QWidget{parent}
{
    m_scrollArea = new QScrollArea(this);
    m_scrollArea->setWidgetResizable(true);

    m_contentWidget = new QWidget(this);
    m_contentWidget->setSizePolicy(QSizePolicy::Preferred,
                                   QSizePolicy::Minimum);
    m_layout = new QVBoxLayout(m_contentWidget);
    m_layout->setAlignment(Qt::AlignJustify);

    m_scrollArea->setWidget(m_contentWidget);

    QVBoxLayout *mainLayout = new QVBoxLayout(this);
    mainLayout->addWidget(m_scrollArea);
    setLayout(mainLayout);
    highlightTimer = new QTimer(this);
    connect(highlightTimer, &QTimer::timeout, this, &ChatWidget::cancelHighlight);
}

void ChatWidget::addMessage(MessageInfo const& info,
                            bool const pushBack)
{
    WindowManager& wm = WindowManager::getInstance();
    MessageWidget *msgWidget = new MessageWidget(info);
    BaseWindow* basewin = reinterpret_cast<BaseWindow*>(wm.getWindow("BaseWindow"));
    connect(msgWidget, &MessageWidget::replyActionSelected, basewin, &BaseWindow::onSelectedMsgAnswer);
    connect(msgWidget, &MessageWidget::replyActionSelected, this, &ChatWidget::onSelectedMsgAnswer);

    connect(msgWidget, &MessageWidget::cancelReplySelected, this, &ChatWidget::onCancelAnswering);
    connect(msgWidget, &MessageWidget::cancelReplySelected, basewin, &BaseWindow::onCancelAnswering);

    connect(msgWidget, &MessageWidget::editActionSelected, this, &ChatWidget::onSelectedMsgEdit);
    connect(msgWidget, &MessageWidget::editActionSelected, basewin, &BaseWindow::onSelectedMsgEdit);

    connect(msgWidget, &MessageWidget::cancelEditSelected, this, &ChatWidget::onCancelEdit);
    connect(msgWidget, &MessageWidget::cancelEditSelected, basewin, &BaseWindow::onCancelEdit);

    connect(msgWidget, &MessageWidget::deleteSelected, this, &ChatWidget::onDeleteMsg);
    connect(msgWidget, &MessageWidget::deleteSelected, basewin, &BaseWindow::onDeleteMsg);

    connect(msgWidget, &MessageWidget::gotoMsg, basewin, &BaseWindow::gotoMsg);

    messages[info.id] = msgWidget;

    if (pushBack) m_layout->addWidget(msgWidget);
    else m_layout->insertWidget(0, msgWidget);

    if (info.id == msgPendingAnswer)
    {
        msgWidget->setStylePendingAnswer();
        msgWidget->selectedReply = true;
    }
    if (info.id == msgPendingEdit)
    {
        msgWidget->setStylePendingEdit();
        msgWidget->selectedEdit = true;
    }
}

void ChatWidget::removeMessage(int64_t const id)
{
    WindowManager& wm = WindowManager::getInstance();
    BaseWindow* basewin = reinterpret_cast<BaseWindow*>(wm.getWindow("BaseWindow"));
    disconnect(messages[id], &MessageWidget::replyActionSelected, basewin, &BaseWindow::onSelectedMsgAnswer);
    disconnect(messages[id], &MessageWidget::replyActionSelected, this, &ChatWidget::onSelectedMsgAnswer);

    disconnect(messages[id], &MessageWidget::cancelReplySelected, this, &ChatWidget::onCancelAnswering);
    disconnect(messages[id], &MessageWidget::cancelReplySelected, basewin, &BaseWindow::onCancelAnswering);

    disconnect(messages[id], &MessageWidget::editActionSelected, this, &ChatWidget::onSelectedMsgEdit);
    disconnect(messages[id], &MessageWidget::editActionSelected, basewin, &BaseWindow::onSelectedMsgEdit);

    disconnect(messages[id], &MessageWidget::cancelEditSelected, this, &ChatWidget::onCancelEdit);
    disconnect(messages[id], &MessageWidget::cancelEditSelected, basewin, &BaseWindow::onCancelEdit);

    disconnect(messages[id], &MessageWidget::deleteSelected, this, &ChatWidget::onDeleteMsg);
    disconnect(messages[id], &MessageWidget::deleteSelected, basewin, &BaseWindow::onDeleteMsg);

    disconnect(messages[id], &MessageWidget::gotoMsg, basewin, &BaseWindow::gotoMsg);

    messages[id]->deleteLater();
    messages.erase(id);
}


void ChatWidget::updateInfo(int64_t const id, MessageInfo const& info)
{
    if (messages.count(id) == 0) return;
    messages[id]->updateInfo(info);
}

void ChatWidget::onDeleteMsg(int64_t const id)
{

}

void ChatWidget::clear()
{
    WindowManager& wm = WindowManager::getInstance();
    BaseWindow* basewin = reinterpret_cast<BaseWindow*>(wm.getWindow("BaseWindow"));
    for (auto const& msg : messages)
    {
        disconnect(msg.second, &MessageWidget::replyActionSelected, basewin, &BaseWindow::onSelectedMsgAnswer);
        disconnect(msg.second, &MessageWidget::replyActionSelected, this, &ChatWidget::onSelectedMsgAnswer);

        disconnect(msg.second, &MessageWidget::cancelReplySelected, this, &ChatWidget::onCancelAnswering);
        disconnect(msg.second, &MessageWidget::cancelReplySelected, basewin, &BaseWindow::onCancelAnswering);

        disconnect(msg.second, &MessageWidget::editActionSelected, this, &ChatWidget::onSelectedMsgEdit);
        disconnect(msg.second, &MessageWidget::editActionSelected, basewin, &BaseWindow::onSelectedMsgEdit);

        disconnect(msg.second, &MessageWidget::cancelEditSelected, this, &ChatWidget::onCancelEdit);
        disconnect(msg.second, &MessageWidget::cancelEditSelected, basewin, &BaseWindow::onCancelEdit);

        disconnect(msg.second, &MessageWidget::deleteSelected, this, &ChatWidget::onDeleteMsg);
        disconnect(msg.second, &MessageWidget::deleteSelected, basewin, &BaseWindow::onDeleteMsg);

        disconnect(msg.second, &MessageWidget::gotoMsg, basewin, &BaseWindow::gotoMsg);

        msg.second->deleteLater();
    }
    messages.clear();
    msgHighlighted = 0;
}

qint64 ChatWidget::messageAmount()
{
    return messages.size();
}

int64_t ChatWidget::getMsgPendingAnswer()
{
    return msgPendingAnswer;
}

int64_t ChatWidget::getMsgPendingEdit()
{
    return msgPendingEdit;
}

void ChatWidget::resetPendingAnswerMsg()
{
    if (messages.count(msgPendingAnswer) != 0)
    {
        messages[msgPendingAnswer]->resetStyle();
        messages[msgPendingAnswer]->selectedReply = false;
    }
    msgPendingAnswer = 0;
}

void ChatWidget::resetPendingEditMsg()
{
    if (messages.count(msgPendingEdit) != 0)
    {
        messages[msgPendingEdit]->resetStyle();
        messages[msgPendingEdit]->selectedEdit = false;
    }
    msgPendingEdit = 0;
}

int64_t ChatWidget::firstMessageID()
{
    if (messages.empty()) return 0;

    return messages.begin()->first;
}

int64_t ChatWidget::lastMessageID()
{
    if (messages.empty()) return 0;

    return messages.rbegin()->first;
}

MessageInfo const& ChatWidget::getMessageInfo(int64_t id)
{
    return messages[id]->getInfo();
}

void ChatWidget::scrollToBottom(int64_t msec)
{
    scroll(msec, 1.0);
}

// 0 means top of the chat, 1 means bottom of the chat
void ChatWidget::scroll(int64_t msec, double const coef)
{
    QPointer<QScrollBar> scrollBar = m_scrollArea->verticalScrollBar();
    QTimer::singleShot(msec, this, [scrollBar, coef]() {
        double const max = static_cast<double>(scrollBar->maximum());
        int const val = static_cast<int>(coef * max);

        if (scrollBar) scrollBar->setValue(val);

    });
}

void ChatWidget::scrollToMid(int64_t msec)
{
    scroll(msec, 0.5);
}

std::vector<int64_t> ChatWidget::getCurrentMessagesID()
{
    std::vector<int64_t> keys;
    keys.reserve(messages.size());
    for (const auto& [key, value] : messages) {
        keys.push_back(key);
    }
    return keys;
}

std::vector<int64_t> ChatWidget::getVisibleMessagesID()
{
    std::vector<int64_t> keys;
    keys.reserve(messages.size());
    for (const auto& [key, value] : messages) {
        if (this->isMsgVisible(key))
        keys.push_back(key);
    }
    return keys;
}

// SLOTS
void ChatWidget::onSelectedMsgAnswer(int64_t id, QString, QString)
{
    if (messages.count(msgPendingAnswer) != 0)
    {
        if (msgHighlighted != msgPendingAnswer)
            messages[msgPendingAnswer]->resetStyle();
        messages[msgPendingAnswer]->selectedReply = false;
    }
    if (messages.count(msgPendingEdit) != 0)
    {
        if (msgHighlighted != msgPendingEdit)
            messages[msgPendingEdit]->resetStyle();
        messages[msgPendingEdit]->selectedEdit = false;
    }

    if (msgHighlighted != id)
        messages[id]->setStylePendingAnswer();
    msgPendingAnswer = id;
    messages[id]->selectedReply = true;
    msgPendingEdit = 0;
}

void ChatWidget::onCancelAnswering(int64_t id)
{
    bool const shouldResetStyle = (msgPendingAnswer != msgHighlighted);
    msgPendingAnswer = 0;
    if (messages.count(id) == 0) return;
    if (shouldResetStyle)
        messages[id]->resetStyle();
    messages[id]->selectedReply = false;
}

void ChatWidget::onSelectedMsgEdit(int64_t id, QString)
{
    if (messages.count(msgPendingEdit) != 0)
    {
        if (msgHighlighted != msgPendingEdit)
            messages[msgPendingEdit]->resetStyle();
        messages[msgPendingEdit]->selectedEdit = false;
    }
    if (messages.count(msgPendingAnswer) != 0)
    {
        if (msgHighlighted != msgPendingAnswer)
            messages[msgPendingAnswer]->resetStyle();
        messages[msgPendingAnswer]->selectedReply = false;
    }
    if (msgHighlighted != id)
        messages[id]->setStylePendingEdit();
    messages[id]->selectedEdit = true;
    msgPendingEdit = id;
    msgPendingAnswer = 0;
}

void ChatWidget::onCancelEdit(int64_t id)
{
    bool const shouldResetStyle = (msgPendingEdit != msgHighlighted);
    msgPendingEdit = 0;
    if (messages.count(id) == 0) return;
    if (shouldResetStyle)
        messages[id]->resetStyle();
    messages[id]->selectedEdit = false;
}

void ChatWidget::resetFilter()
{
    filterContent = "";
    isFilterDtEnabled = false;
}

bool ChatWidget::isMsgVisible(int64_t id)
{
    if (!isMsgPresent(id)) return false;

    MessageWidget* widget = messages[id];
    if (!widget->isVisible()) return false;

    QPoint widgetTopLeftGlobal = widget->mapToGlobal(QPoint(0, 0));
    QPoint widgetBottomRightGlobal = widget->mapToGlobal(QPoint(widget->width(), widget->height()));
    QRect widgetGlobalRect(widgetTopLeftGlobal, widgetBottomRightGlobal);

    QPoint viewportTopLeftGlobal = m_scrollArea->viewport()->mapToGlobal(QPoint(0, 0));
    QRect viewportGlobalRect(viewportTopLeftGlobal, m_scrollArea->viewport()->size());

    // Check intersection
    return viewportGlobalRect.intersects(widgetGlobalRect);
}

bool ChatWidget::isMsgPresent(int64_t id)
{
    return messages.count(id) != 0;
}

// tries to place a message within the chat's scope
// with a given id to the center of the chat
void ChatWidget::gotoMessage(int64_t id, int64_t msecs)
{
    if (messages.count(id) == 0) return;
    QPointer<QScrollBar> bar = m_scrollArea->verticalScrollBar();
    MessageWidget* msg = messages[id];
    int const pos = msg->mapToParent(QPoint(0, 0)).y() - this->size().height()/2 + msg->getHeight()/2;
    QTimer::singleShot(msecs, this, [bar, pos](){ if (bar) bar->setValue(pos); });
}

void ChatWidget::highlight(int64_t id, int msecs)
{
    cancelHighlight();
    if (messages.count(id) == 0) return;
    msgHighlighted = id;
    messages[id]->setColor("#c0c0c0");
    highlightTimer->start(msecs);
}

void ChatWidget::cancelHighlight()
{
    if (messages.count(msgHighlighted) == 0) {}
    else if (msgHighlighted == msgPendingAnswer)
        messages[msgHighlighted]->setStylePendingAnswer();
    else if (msgHighlighted == msgPendingEdit)
        messages[msgHighlighted]->setStylePendingEdit();
    else
        messages[msgHighlighted]->resetStyle();

    msgHighlighted = 0;
    highlightTimer->stop();
}

// This would be called only if there are many messages in the chat already
bool ChatWidget::isScrolledUp()
{
    QPointer<QScrollBar> scrollBar = m_scrollArea->verticalScrollBar();
    double const val = static_cast<double>(scrollBar->value());
    double const max = static_cast<double>(scrollBar->maximum());
    //return (val/max) < 0.15;
    return isMsgVisible(firstMessageID());
}

bool ChatWidget::isScrolledDown()
{
    QPointer<QScrollBar> scrollBar = m_scrollArea->verticalScrollBar();
    double const val = static_cast<double>(scrollBar->value());
    double const max = static_cast<double>(scrollBar->maximum());
    //return (val/max) > 0.85;
    return isMsgVisible(lastMessageID());
}

void ChatWidget::pop_back()
{
    if (messages.empty()) return;
    removeMessage(lastMessageID());
}

void ChatWidget::pop_front()
{
    if (messages.empty()) return;
    removeMessage(firstMessageID());
}
